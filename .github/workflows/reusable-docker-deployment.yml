name: Reusable workflow to deploy Docker image on AWS EC2 instance

on:
  workflow_call:
    inputs:
      isMainnet:
        description: 'Whether this deployment is for mainnet'
        required: true
        type: boolean
      ecr-repo:
        description: 'Name of the ECR repository'
        required: true
        type: string
      ecr-repo-aws-region:
        description: 'AWS Region of the ECR repository'
        required: true
        type: string
      aws-secret-name:
        description: 'Name of the secret in AWS Secrets Manager'
        required: true
        type: string
      composefile-path:
        description: 'Path to the docker-compose.yml file'
        required: true
        type: string
      role-arn-dev-testnet:
        description: 'ARN of the IAM Role to assume for dev and testnet'
        required: true
        type: string
      role-arn-mainnet:
        description: 'ARN of the IAM Role to assume for mainnet'
        required: true
        type: string
    secrets:
      EC2_SSH_KEY:
        description: 'Private SSH key for dev/testnet EC2 instances'
        required: true
      EC2_USER:
        description: 'SSH user for dev/testnet EC2 instances'
        required: true
      EC2_HOST:
        description: 'Optional EC2 host for dev (leave blank for testnet auto-discovery)'
        required: false
      ECR_REGISTRY:
        description: 'ECR registry URI'
        required: true
      BASTION_SSH_KEY:
        description: 'Private SSH key for mainnet bastion host'
        required: true
      MAINNET_NODE_SSH_KEY:
        description: 'Private SSH key for mainnet EC2 instances'
        required: true
      BASTION_USER:
        description: 'SSH user for mainnet bastion host'
        required: true
      BASTION_HOST:
        description: 'Hostname or IP of mainnet bastion host'
        required: true
      MAINNET_NODE_USER:
        description: 'SSH user for mainnet EC2 instances'
        required: true

env:
  AWS_REGION: us-west-1
  AWS_DEFAULT_DEPLOYMENT_PATH: /data/treasurenet
  SERVICE_NAME: services

permissions:
  id-token: write       # needed for OIDC federation
  contents: read        # needed for actions/checkout

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: "Configure AWS Credentials (Dev/Test)"
        if: ${{ !inputs.isMainnet }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::381492270411:role/GitHubActionsOIDCRole
          aws-region: ${{ inputs.s3-aws-region }}

      - name: "Configure AWS Credentials (Mainnet)"
        if: ${{ inputs.isMainnet }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Export AWS credentials to environment
        run: |
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"       >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN"        >> $GITHUB_ENV

      # ——— DEV / TESTNET: set or discover EC2_HOST ———
      - name: Set EC2_HOST from secret (dev)
        if: ${{ !inputs.isMainnet && secrets.EC2_HOST }}
        run: echo "EC2_HOST=${{ secrets.EC2_HOST }}" >> $GITHUB_ENV

      - name: Discover EC2_HOST via AWS API (testnet)
        if: ${{ !inputs.isMainnet && !secrets.EC2_HOST }}
        run: |
          public_ip=$(aws ec2 describe-instances \
            --region ${{ inputs.ecr-repo-aws-region }} \
            --filters \
              "Name=tag:Name,Values=${{ env.SERVICE_NAME }}" \
              "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].PublicIpAddress" \
            --output text)
          echo "EC2_HOST=$public_ip"       >> $GITHUB_ENV
          echo "EC2_USER=${{ secrets.EC2_USER }}" >> $GITHUB_ENV

      - name: Retrieve application secrets
        run: |
          SECRET_STRING=$(aws secretsmanager get-secret-value \
            --secret-id ${{ inputs.aws-secret-name }} \
            --region ${{ inputs.ecr-repo-aws-region }} \
            --query SecretString --output text)
          echo "${SECRET_STRING}" \
            | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' \
            > .env

      # ——— DEV / TESTNET: prepare SSH and deploy ———
      - name: Prepare SSH for dev/testnet
        if: ${{ !inputs.isMainnet }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Deploy to dev/testnet
        if: ${{ !inputs.isMainnet }}
        run: |
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ inputs.composefile-path }} .env \
            ${{ secrets.EC2_USER }}@${{ env.EC2_HOST }}:~/
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ secrets.EC2_USER }}@${{ env.EC2_HOST }} << 'EOF'
            mkdir -p ${{ env.AWS_DEFAULT_DEPLOYMENT_PATH }}/${{ inputs.ecr-repo }}
            cd    ${{ env.AWS_DEFAULT_DEPLOYMENT_PATH }}/${{ inputs.ecr-repo }}
            mv ~/$(basename ${{ inputs.composefile-path }}) ./docker-compose.yml
            mv ~/.env              ./.env
            sed -i '/image:/s|image:.*|image: ${{ secrets.ECR_REGISTRY }}/${{ inputs.ecr-repo }}:${{ github.sha }}|' docker-compose.yml
            aws ecr get-login-password --region ${{ inputs.ecr-repo-aws-region }} \
              | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
            docker-compose down
            docker-compose pull
            docker-compose up -d
          EOF

      # ——— MAINNET: prepare bastion SSH key ———
      - name: Prepare SSH for mainnet bastion
        if: ${{ inputs.isMainnet }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.BASTION_SSH_KEY }}" > ~/.ssh/bastion_id_rsa
          chmod 600 ~/.ssh/bastion_id_rsa

      - name: Upload files to bastion host (mainnet)
        if: ${{ inputs.isMainnet }}
        run: |
          scp -o StrictHostKeyChecking=no \
            -i ~/.ssh/bastion_id_rsa \
            ${{ inputs.composefile-path }} .env \
            ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }}:~/

      - name: Deploy and restart nodes on mainnet
        if: ${{ inputs.isMainnet }}
        run: |
          ssh -o StrictHostKeyChecking=no \
            -i ~/.ssh/bastion_id_rsa \
            ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }} << 'OUTER_EOF'
            # copy compose + env into target instance
            scp -o StrictHostKeyChecking=no \
              -i ~/mainnet-node.pem \
              ~/$(basename ${{ inputs.composefile-path }}) \
              ${{ secrets.MAINNET_NODE_USER }}@${{ env.EC2_HOST }}:/home/${{ secrets.MAINNET_NODE_USER }}/${{ inputs.ecr-repo }}.yml
            scp -o StrictHostKeyChecking=no \
              -i ~/mainnet-node.pem \
              ~/.env \
              ${{ secrets.MAINNET_NODE_USER }}@${{ env.EC2_HOST }}:/home/${{ secrets.MAINNET_NODE_USER }}/.env

            # login and deploy
            ssh -o StrictHostKeyChecking=no \
              -i ~/mainnet-node.pem \
              ${{ secrets.MAINNET_NODE_USER }}@${{ env.EC2_HOST }} << 'INNER_EOF'
              mkdir -p /home/${{ secrets.MAINNET_NODE_USER }}/${{ inputs.ecr-repo }}
              cd /home/${{ secrets.MAINNET_NODE_USER }}/${{ inputs.ecr-repo }}
              mv /home/${{ secrets.MAINNET_NODE_USER }}/${{ inputs.ecr-repo }}.yml ./docker-compose.yml
              mv /home/${{ secrets.MAINNET_NODE_USER }}/.env ./.env
              sed -i '/image:/s|image:.*|image: ${{ secrets.ECR_REGISTRY }}/${{ inputs.ecr-repo }}:${{ github.sha }}|' docker-compose.yml
              aws ecr get-login-password --region ${{ inputs.ecr-repo-aws-region }} \
                | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
              docker compose down
              docker compose pull
              docker compose up -d
            INNER_EOF
          OUTER_EOF

      - name: Clean up Docker credentials
        run: rm -f /home/runner/.docker/config.json

