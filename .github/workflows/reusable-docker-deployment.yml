name: Reusable workflow to deploy Docker image on AWS EC2 instance

on:
  workflow_call:
    inputs:
      gha-role-name:
        description: 'Name of the IAM Role to assume in the AWS Management Account'
        required: true
        type: string
      ecr-repo:
        description: 'name of the ECR repository'
        required: true
        type: string
      ecr-repo-aws-region:
        description: 'AWS Region for ECR Repository'
        required: true
        type: string
      aws-secret-name:
        description: 'Name of the secret in AWS Secrets Manager'
        required: true
        type: string
      composefile-path:
        description: 'Path to the docker-compose.yml file'
        required: true
        type: string
      isMainnet:
        description: 'Whether we are deploying to mainnet'
        required: true
        type: boolean
    secrets:
      EC2_SSH_KEY:
        description: 'Private SSH key for dev/testnet EC2 instances'
        required: true
      EC2_USER:
        description: 'SSH user for dev/testnet EC2 instances'
        required: true
      EC2_HOST:
        description: 'Optional EC2 host for dev (leave blank for testnet auto-discovery)'
        required: false
      ECR_REGISTRY:
        description: 'ECR registry URI'
        required: true


env:
  AWS_REGION: us-west-1
  AWS_DEFAULT_DEPLOYMENT_PATH: /data/treasurenet
  SERVICE_NAME: services
  EC2_HOST_SECRET: ${{ secrets.EC2_HOST }}
  EC2_USER_SECRET: ${{ secrets.EC2_USER }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}


permissions:
  id-token: write       # needed for OIDC federation
  contents: read        # needed for actions/checkout

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: "Configure AWS Credentials (Dev/Test)"
        if: ${{ !inputs.isMainnet }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::381492270411:role/GitHubActionsOIDCRole
          aws-region: ${{ inputs.s3-aws-region }}

      - name: "Configure AWS Credentials (Mainnet)"
        if: ${{ inputs.isMainnet }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: Export AWS credentials to environment
        run: |
          echo "AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID"       >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$AWS_SESSION_TOKEN"        >> $GITHUB_ENV

      # ——— DEV / TESTNET: set or discover EC2_HOST ———
      - name: Set EC2_HOST from secret (dev)
        if: ${{ !inputs.isMainnet && env.EC2_HOST_SECRET }}
        run: echo "EC2_HOST=${{ env.EC2_HOST_SECRET }}" >> $GITHUB_ENV

      - name: Discover EC2_HOST via AWS API (testnet)
        if: ${{ !inputs.isMainnet && !env.EC2_HOST_SECRET }}
        run: |
          public_ip=$(aws ec2 describe-instances \
            --region ${{ inputs.ecr-repo-aws-region }} \
            --filters \
              "Name=tag:Name,Values=${{ env.SERVICE_NAME }}" \
              "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].PublicIpAddress" \
            --output text)
          echo "EC2_HOST=$public_ip"       >> $GITHUB_ENV
          echo "EC2_USER=${{ env.EC2_USER_SECRET }}" >> $GITHUB_ENV

      - name: Retrieve application secrets
        run: |
          SECRET_STRING=$(aws secretsmanager get-secret-value \
            --secret-id ${{ inputs.aws-secret-name }} \
            --region ${{ inputs.ecr-repo-aws-region }} \
            --query SecretString --output text)
          echo "${SECRET_STRING}" \
            | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' \
            > .env

      # ——— DEV / TESTNET: prepare SSH and deploy ———
      - name: Prepare SSH for dev/testnet
        if: ${{ !inputs.isMainnet }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Deploy to dev/testnet
        if: ${{ !inputs.isMainnet }}
        run: |
          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ inputs.composefile-path }} .env \
            ${{ env.EC2_USER_SECRET }}@${{ env.EC2_HOST }}:~/
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no \
            ${{ env.EC2_USER_SECRET }}@${{ env.EC2_HOST }} << 'EOF'
            mkdir -p ${{ env.AWS_DEFAULT_DEPLOYMENT_PATH }}/${{ inputs.ecr-repo }}
            cd    ${{ env.AWS_DEFAULT_DEPLOYMENT_PATH }}/${{ inputs.ecr-repo }}
            mv ~/$(basename ${{ inputs.composefile-path }}) ./docker-compose.yml
            mv ~/.env              ./.env
            sed -i '/image:/s|image:.*|image: ${{ env.ECR_REGISTRY }}/${{ inputs.ecr-repo }}:${{ github.sha }}|' docker-compose.yml
            aws ecr get-login-password --region ${{ inputs.ecr-repo-aws-region }} \
              | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
            docker-compose down
            docker-compose pull
            docker-compose up -d
          EOF

      # ——— MAINNET: prepare bastion SSH key ———
      - name: Prepare SSH for mainnet bastion
        if: ${{ inputs.isMainnet }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/bastion_id_rsa
          chmod 600 ~/.ssh/bastion_id_rsa

      - name: Upload files to bastion host (mainnet)
        if: ${{ inputs.isMainnet }}
        run: |
          scp -o StrictHostKeyChecking=no \
            -i ~/.ssh/bastion_id_rsa \
            ${{ inputs.composefile-path }} .env \
            ec2-user@$jump-server-us-west-1:~/

      - name: Deploy and restart nodes on mainnet
        if: ${{ inputs.isMainnet }}
        run: |
          ssh -o StrictHostKeyChecking=no \
            -i ~/.ssh/bastion_id_rsa \
            ec2-user@$jump-server-us-west-1 << 'OUTER_EOF'
            # copy compose + env into target instance
          scp -o StrictHostKeyChecking=no \
            -i ~/mainnet-nodes-us-west-1.pem \
            ${{ inputs.composefile-path }} ubuntu@${{ env.EC2_HOST }}:/home/ubuntu/${{ inputs.ecr-repo }}.yml

          scp -o StrictHostKeyChecking=no \
            -i ~/mainnet-nodes-us-west-1.pem \
            .env ubuntu@${{ env.EC2_HOST }}:/home/ubuntu/.env

            # login and deploy
          ssh -o StrictHostKeyChecking=no \
            -i ~/mainnet-nodes-us-west-1.pem \
            ubuntu@${{ env.EC2_HOST }} << 'INNER_EOF'
          mkdir -p /home/ubuntu/${{ inputs.ecr-repo }}
          cd /home/ubuntu/${{ inputs.ecr-repo }}
          mv /home/ubuntu/${{ inputs.ecr-repo }}.yml ./docker-compose.yml
          mv /home/ubuntu/.env ./.env
          sed -i '/image:/s|image:.*|image: ${{ secrets.ECR_REGISTRY }}/${{ inputs.ecr-repo }}:${{ github.sha }}|' docker-compose.yml
          aws ecr get-login-password --region ${{ inputs.ecr-repo-aws-region }} \
            | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}
          docker compose down
          docker compose pull
          docker compose up -d
          INNER_EOF
          OUTER_EOF

      - name: Clean up Docker credentials
        run: rm -f /home/runner/.docker/config.json

