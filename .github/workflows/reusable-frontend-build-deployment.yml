# Reusable GitHub Actions workflow for building and deploying frontend to EC2
# Uses OIDC for authentication in all environments (dev/test/mainnet)
name: "Frontend Build and Deploy"

on:
  workflow_call:
    inputs:
      repo-name:
        description: 'Name of the repository/artifact'
        required: true
        type: string
      node-version:
        description: 'Node.js version to use'
        required: true
        type: string
      build-command:
        description: 'npm build script to run'
        required: true
        type: string
      s3-aws-region:
        description: 'AWS region for S3 operations'
        required: true
        type: string
      isMainnet:
        description: 'Flag to indicate mainnet deployment'
        required: true
        type: boolean
    secrets:
      EC2_SSH_KEY:
        description: 'Private SSH key to connect to EC2'
        required: true
      EC2_USER:
        description: 'Username for SSH on EC2'
        required: true
      EC2_HOST:
        description: 'EC2 hostname or IP'
        required: true
      CLOUDFLARE_API_TOKEN:
        description: 'Cloudflare API token for cache purge'
        required: true
      CLOUDFLARE_ZONE_ID:
        description: 'Cloudflare zone identifier'
        required: true

# Global environment variables
env:
  AWS_ROLE_ARN: "arn:aws:iam::471112752664:role/GitHubAction-AssumeRoleWithAction"
  AWS_REGION: "us-west-1"
  AWS_DEFAULT_DEPLOYMENT_PATH: "/data/treasurenet"
  MAINNET_DEPLOYMENT_PATH: "/home/ubuntu/treasurenet"
  BUCKET_NAME: "tn-deployment-file-archive"
  MAINNET_BUCKET_NAME: "tn-mainnet-deployment-file-archive"
  SERVICE_TAG: "services"
  NGINX_PATH: "/data/nginx"
  MAINNET_NGINX_PATH: "/home/ubuntu/nginx"
  DEV_SECRET_PREFIX: "dev/services"
  TESTNET_SECRET_PREFIX: "testnet/services"
  MAINNET_SECRET_PREFIX: "mainnet/services"

# Use OIDC for authentication and grant minimal permissions
permissions:
  id-token: write     # required for OIDC
  contents: read      # read repository code

jobs:
  build-and-deploy:
    runs-on: self-hosted
    steps:
      - name: "Initialize Environment Variables"
        run: |
          # Store current date and time for artifact versioning
          echo "DATE=$(date '+%Y%m%d')" >> $GITHUB_ENV
          echo "TIME=$(date '+%Y%m%d_%H%M%S')" >> $GITHUB_ENV

      - name: "Checkout Repository"
        uses: actions/checkout@v4

      - name: "Set Up Node.js"
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}

      - name: "Configure AWS Credentials (Dev/Test)"
        if: ${{ !inputs.isMainnet }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::381492270411:role/GitHubActionsOIDCRole
          aws-region: ${{ inputs.s3-aws-region }}

      - name: "Configure AWS Credentials (Mainnet)"
        if: ${{ inputs.isMainnet }}
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ env.AWS_REGION }}

      - name: "Discover EC2 Instance"
        run: |
          if [ "${{ inputs.isMainnet }}" = "true" ]; then
            # Query mainnet EC2 by specific tag
            public_dns=$(aws ec2 describe-instances \
              --region ${{ env.AWS_REGION }} \
              --filters "Name=tag:Name,Values=web-service-1-us-west-1" "Name=instance-state-name,Values=running" \
              --query "Reservations[].Instances[].PublicDnsName" \
              --output text)
            echo "EC2_HOST=$public_dns" >> $GITHUB_ENV
          else
            # Query dev/test EC2 by general tag
            public_ip=$(aws ec2 describe-instances \
              --region ${{ inputs.s3-aws-region }} \
              --filters "Name=tag:Name,Values=${{ env.SERVICE_TAG }}" "Name=instance-state-name,Values=running" \
              --query "Reservations[].Instances[].PublicIpAddress" \
              --output text)
            echo "EC2_HOST=$public_ip" >> $GITHUB_ENV
          fi
          echo "EC2_USER=ubuntu" >> $GITHUB_ENV

      - name: "Install Dependencies and Build"
        run: |
          npm install --silent
          npm run ${{ inputs.build-command }} --silent

      - name: "Package Build Artifacts"
        run: |
          tar -zcvf ./${{ inputs.repo-name }}.tar.gz -C dist .
          tar -zcvf ./${{ inputs.repo-name }}_nginx.tar.gz -C nginx .

      - name: "Fetch Nginx Certificates"
        run: |
          prefix=$([[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_SECRET_PREFIX }} || echo ${{ env.DEV_SECRET_PREFIX }}/${{ (env.EC2_HOST) && echo env.TESTNET_SECRET_PREFIX || echo env.DEV_SECRET_PREFIX }})
          secret=$(aws secretsmanager get-secret-value \
            --secret-id "${prefix}/nginx" \
            --region ${{ inputs.s3-aws-region }} \
            --query SecretString --output text)
          echo "$secret" | jq -r .ssl_certificate > cloudflare.pem
          echo "$secret" | jq -r .ssl_key         > cloudflare.key

      - name: "Configure SSH Key"
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: "Upload Artifacts to S3"
        run: |
          bucket=$([[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_BUCKET_NAME }} || echo ${{ env.BUCKET_NAME }})
          aws s3 cp cloudflare.pem  s3://$bucket/${{ inputs.repo-name }}/${{ env.DATE }}/cloudflare.pem
          aws s3 cp cloudflare.key  s3://$bucket/${{ inputs.repo-name }}/${{ env.DATE }}/cloudflare.key
          aws s3 cp ./${{ inputs.repo-name }}.tar.gz s3://$bucket/${{ inputs.repo-name }}/${{ env.DATE }}/${{ inputs.repo-name }}_${{ env.TIME }}.tar.gz
          aws s3 cp ./${{ inputs.repo-name }}_nginx.tar.gz s3://$bucket/${{ inputs.repo-name }}/${{ env.DATE }}/${{ inputs.repo-name }}_nginx_${{ env.TIME }}.tar.gz

      - name: "Deploy to EC2"
        run: |
          dest_path=$([[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_DEPLOYMENT_PATH }} || echo ${{ env.AWS_DEFAULT_DEPLOYMENT_PATH }})
          scmd="aws s3 cp s3://$( [[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_BUCKET_NAME }} || echo ${{ env.BUCKET_NAME }} )/${{ inputs.repo-name }}/${{ env.DATE }}/${{ inputs.repo-name }}_${{ env.TIME }}.tar.gz /home/${EC2_USER}/${{ inputs.repo-name }}.tar.gz && \
            tar -zxf /home/${EC2_USER}/${{ inputs.repo-name }}.tar.gz -C $dest_path && \
            aws s3 cp s3://$( [[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_BUCKET_NAME }} || echo ${{ env.BUCKET_NAME }} )/${{ inputs.repo-name }}/${{ env.DATE }}/${{ inputs.repo-name }}_nginx_${{ env.TIME }}.tar.gz /home/${EC2_USER}/${{ inputs.repo-name }}_nginx.tar.gz && \
            tar -zxf /home/${EC2_USER}/${{ inputs.repo-name }}_nginx.tar.gz -C $( [[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_NGINX_PATH }} || echo ${{ env.NGINX_PATH }} )"
          ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} "$scmd"

      - name: "Start Nginx Container"
        run: |
          remote_path=$( [[ "${{ inputs.isMainnet }}" == "true" ]] && echo ${{ env.MAINNET_NGINX_PATH }} || echo ${{ env.NGINX_PATH }} )
          cmd="cd $remote_path && (docker-compose ps | grep -q Up && docker-compose restart || docker-compose up -d)"
          ssh -o StrictHostKeyChecking=no ${EC2_USER}@${EC2_HOST} "$cmd"

      - name: "Purge Cloudflare Cache"
        run: |
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${CLOUDFLARE_ZONE_ID}/purge_cache" \
            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}'
